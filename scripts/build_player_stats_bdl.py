#!/usr/bin/env python3
"""
build_player_stats_bdl.py

Generates player_stats.json using the BallDontLie API.

This script:
 • Loads rosters.json (generated by build_rosters_bdl.py)
 • Loads schedule.json to figure out today's opponent
 • Builds:
       – season averages (per-game)
       – last 5 game rolling averages
 • Produces clean player objects matching your UI

Environment:
 BALLDONTLIE_API_KEY = your BDL Bearer token
"""

import json
import os
import sys
from datetime import date
from time import sleep
import requests


# ---------------------------------------------------------------------------
# CONFIG
# ---------------------------------------------------------------------------

BDL_BASE = "https://api.balldontlie.io/v1"

API_KEY = os.getenv("BALLDONTLIE_API_KEY", "").strip()
if not API_KEY:
   print("ERROR: BALLDONTLIE_API_KEY is not set", file=sys.stderr)
   sys.exit(1)


# ---------------------------------------------------------------------------
# UTILITIES
# ---------------------------------------------------------------------------

def bdl_get(path: str, params=None) -> dict:
   """Low-level GET wrapper with retries."""
   url = f"{BDL_BASE}/{path}"
   headers = {
       "Authorization": f"Bearer {API_KEY}",
       "Accept": "application/json"
   }

   for attempt in range(3):
       try:
           r = requests.get(url, headers=headers, params=params, timeout=25)
           r.raise_for_status()
           return r.json()
       except requests.RequestException as e:
           print(f"[bdl_get] ERROR: {e} attempt {attempt+1}", file=sys.stderr)
           if attempt == 2:
               raise
           sleep(1.2)

   raise RuntimeError("bdl_get failed after retries")


def parse_minutes(min_str: str | None) -> float:
   """
   BDL returns minutes like "31:22".
   Return decimal minutes (31.4).
   """
   if not min_str:
       return 0.0
   try:
       mm, ss = min_str.split(":")
       return round(int(mm) + int(ss) / 60.0, 1)
   except Exception:
       return 0.0


def today_string() -> str:
   return date.today().isoformat()


TODAY = today_string()


# ---------------------------------------------------------------------------
# FETCH LEAGUE PLAYERS (ID + TEAM)
# ---------------------------------------------------------------------------

def fetch_players_index() -> dict:
   """
   Returns:
       { normalized_full_name: { id, full_name, team } }
   """
   print("Fetching BallDontLie player index…", file=sys.stderr)

   index = {}
   page = 1
   per_page = 100

   while True:
       data = bdl_get("players", params={"page": page, "per_page": per_page})
       players = data.get("data", [])
       if not players:
           break

       for p in players:
           first = p.get("first_name", "").strip()
           last = p.get("last_name", "").strip()
           full = f"{first} {last}".strip()
           key = (
               full.lower()
               .replace(".", "")
               .replace("'", "")
               .replace("-", " ")
               .strip()
           )
           team = (p.get("team") or {}).get("abbreviation")

           index[key] = {
               "id": p["id"],
               "full_name": full,
               "team": team,
           }

       meta = data.get("meta", {})
       total_pages = meta.get("total_pages", page)
       print(f"  player index page {page}/{total_pages}", file=sys.stderr)

       if page >= total_pages:
           break
       page += 1

   print(f"Indexed {len(index)} players.", file=sys.stderr)
   return index


# ---------------------------------------------------------------------------
# FETCH STATS
# ---------------------------------------------------------------------------

def fetch_season_avg(pid: int, season: int) -> dict | None:
   """
   Return dict of season averages for a single player.
   Endpoint:
       GET /season_averages?season=YYYY&player_ids[]=PID
   """
   params = {
       "season": season,
       "player_ids[]": pid,
   }
   data = bdl_get("season_averages", params=params)
   arr = data.get("data", [])
   return arr[0] if arr else None


def fetch_last5(pid: int, season: int) -> dict | None:
   """
   Return last-5 rolling averages: pts / reb / ast.
   Endpoint:
       GET /stats?seasons[]=YYYY&player_ids[]=pid&per_page=5&sort=game.date:desc
   """
   params = {
       "seasons[]": season,
       "player_ids[]": pid,
       "per_page": 5,
       "page": 1,
       "sort": "game.date:desc",
       "postseason": "false",
   }
   data = bdl_get("stats", params=params)
   games = data.get("data", [])
   if not games:
       return None

   n = len(games)
   return {
       "pts": round(sum(g.get("pts", 0) for g in games) / n, 1),
       "reb": round(sum(g.get("reb", 0) for g in games) / n, 1),
       "ast": round(sum(g.get("ast", 0) for g in games) / n, 1),
   }


# ---------------------------------------------------------------------------
# TODAY'S OPPONENTS — from schedule.json
# ---------------------------------------------------------------------------

def load_schedule():
   with open("schedule.json", "r", encoding="utf-8") as f:
       return json.load(f)


def today_opponents(schedule: dict) -> dict:
   """Return { team: opponent } mapping for today's games."""
   mapping = {}
   today_games = schedule.get(TODAY, []) or []

   for g in today_games:
       home = g["home_team"]
       away = g["away_team"]
       mapping[home] = away
       mapping[away] = home

   return mapping


# ---------------------------------------------------------------------------
# MAIN BUILD
# ---------------------------------------------------------------------------

def detect_season() -> int:
   """
   BDL's season uses the YEAR the season starts.
   Example: 2025-26 season → 2025.
   """
   today = date.today()
   if today.month >= 10:
       return today.year
   return today.year - 1


SEASON = detect_season()
print(f"Using BDL Season: {SEASON}", file=sys.stderr)
print(f"Today: {TODAY}", file=sys.stderr)


def build_player_stats():
   # Load rosters
   with open("rosters.json", "r", encoding="utf-8") as f:
       rosters = json.load(f)

   schedule = load_schedule()
   opp_map = today_opponents(schedule)
   player_index = fetch_players_index()

   final = {}
   missing = []

   avg_cache = {}
   last5_cache = {}

   for team, players in rosters.items():
       for name in players:
           norm = (
               name.lower()
               .replace(".", "")
               .replace("'", "")
               .replace("-", " ")
               .strip()
           )

           info = player_index.get(norm)
           if not info:
               missing.append((name, team))
               pid = None
               avg = None
               last5 = None
           else:
               pid = info["id"]
               if pid not in avg_cache:
                   avg_cache[pid] = fetch_season_avg(pid, SEASON)
               if pid not in last5_cache:
                   last5_cache[pid] = fetch_last5(pid, SEASON)

               avg = avg_cache[pid]
               last5 = last5_cache[pid]

           # Season stats
           games = avg.get("games_played", 0) if avg else 0
           min_val = parse_minutes(avg.get("min")) if avg else 0.0

           pts = float(avg.get("pts", 0)) if avg else 0.0
           reb = float(avg.get("reb", 0)) if avg else 0.0
           ast = float(avg.get("ast", 0)) if avg else 0.0

           fg_pct = avg.get("fg_pct") if avg else None
           fg3_pct = avg.get("fg3_pct") if avg else None
           ft_pct = avg.get("ft_pct") if avg else None

           # Last 5
           l5p = last5["pts"] if last5 else 0.0
           l5r = last5["reb"] if last5 else 0.0
           l5a = last5["ast"] if last5 else 0.0

           final[name] = {
               "team": team,
               "season": SEASON,

               "games": games,
               "min": min_val,
               "pts": pts,
               "reb": reb,
               "ast": ast,

               "fg_pct": fg_pct,
               "fg3_pct": fg3_pct,
               "ft_pct": ft_pct,

               "last5_pts": l5p,
               "last5_reb": l5r,
               "last5_ast": l5a,

               "opponent": opp_map.get(team),
               "def_rank": None,           # BDL doesn't include defense
               "team_record": None,
               "team_win_pct": None,
               "opp_record": None,
               "opp_win_pct": None,
               "opp_streak": None,
               "opp_points_for": None,
               "opp_points_against": None,
               "opp_conf_rank": None,
               "opp_div_rank": None,

               # UI placeholders
               "usage": 0.0,
               "pace": None,
           }

   if missing:
       print("\nPlayers NOT matched to BDL:", file=sys.stderr)
       for name, team in missing:
           print(f"  - {name} ({team})", file=sys.stderr)

   return final


def main():
   print("Building player_stats.json from BallDontLie…", file=sys.stderr)

   stats = build_player_stats()

   with open("player_stats.json", "w", encoding="utf-8") as f:
       json.dump(stats, f, indent=2)

   print(f"Wrote {len(stats)} players to player_stats.json.", file=sys.stderr)


if __name__ == "__main__":
   main()
