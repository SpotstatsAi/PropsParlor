#!/usr/bin/env python3
"""
build_player_stats_bdl.py

The final BallDontLie-based stats builder:

- Reads rosters.json (generated by build_rosters_bdl.py)
- Reads schedule.json (your custom daily file)
- Fetches:
   * Season averages (per-game)
   * Last 5-game rolling averages
- Automatically maps each roster player to their BallDontLie ID
- Outputs a clean player_stats.json that matches your UI perfectly

Environment:
 BALLDONTLIE_API_KEY   -> your premium API key
 BDL_SEASON            -> optional override, e.g. 2025 for 2025-26 season
"""

import json
import os
import sys
from datetime import date
from time import sleep
import requests

BDL_BASE = "https://api.balldontlie.io/v1"

API_KEY = os.getenv("BALLDONTLIE_API_KEY", "").strip()
if not API_KEY:
   print("ERROR: BALLDONTLIE_API_KEY is missing", file=sys.stderr)
   sys.exit(1)


# ---------------------------------------------------------------------------
# Season detection
# ---------------------------------------------------------------------------

def detect_season() -> int:
   override = os.getenv("BDL_SEASON")
   if override:
       try:
           return int(override)
       except:
           pass

   today = date.today()

   if today.month >= 10:  # Oct/Nov/Dec
       return today.year
   return today.year - 1


SEASON = detect_season()
TODAY = date.today().isoformat()

print(f"Using BallDontLie season = {SEASON}", file=sys.stderr)
print(f"Today = {TODAY}", file=sys.stderr)


# ---------------------------------------------------------------------------
# Helper functions
# ---------------------------------------------------------------------------

def bdl_get(path: str, params: dict | None = None) -> dict:
   """BallDontLie GET wrapper with retry."""
   url = f"{BDL_BASE}/{path}"
   headers = {"Authorization": f"Bearer {API_KEY}", "Accept": "application/json"}

   for attempt in range(3):
       try:
           r = requests.get(url, headers=headers, params=params, timeout=30)
           r.raise_for_status()
           return r.json()
       except Exception as e:
           print(f"[bdl_get] ERROR {attempt+1}/3: {e}", file=sys.stderr)
           if attempt == 2:
               raise
           sleep(1.2)


def parse_minutes(min_str: str | None) -> float:
   """Convert MM:SS → decimal minutes."""
   if not min_str:
       return 0.0
   try:
       m, s = min_str.split(":")
       return round(int(m) + int(s) / 60, 1)
   except:
       return 0.0


# ---------------------------------------------------------------------------
# Fetch players index (ID + name + team)
# ---------------------------------------------------------------------------

def fetch_players_index() -> dict:
   print("Fetching BDL player index…", file=sys.stderr)

   players = {}
   page = 1
   per_page = 100

   while True:
       data = bdl_get("players", {"page": page, "per_page": per_page, "active": "true"})
       arr = data.get("data", [])
       meta = data.get("meta", {})
       total_pages = meta.get("total_pages", 1)

       print(f"  page {page}/{total_pages}", file=sys.stderr)

       if not arr:
           break

       for p in arr:
           pid = p["id"]
           team = (p.get("team") or {}).get("abbreviation")
           first = p.get("first_name", "").strip()
           last = p.get("last_name", "").strip()
           full = f"{first} {last}".strip()

           players[full] = {
               "id": pid,
               "team": team,
               "full_name": full,
           }

       if page >= total_pages:
           break
       page += 1

   print(f"Indexed {len(players)} players", file=sys.stderr)
   return players


# ---------------------------------------------------------------------------
# API fetchers
# ---------------------------------------------------------------------------

def fetch_season_avg(pid: int) -> dict | None:
   params = {"season": SEASON, "player_ids[]": pid}
   data = bdl_get("season_averages", params)
   arr = data.get("data", [])
   return arr[0] if arr else None


def fetch_last5(pid: int) -> dict | None:
   params = {
       "seasons[]": SEASON,
       "player_ids[]": pid,
       "per_page": 5,
       "page": 1,
       "postseason": "false",
       "sort": "game.date:desc",
   }
   data = bdl_get("stats", params)
   games = data.get("data", [])
   if not games:
       return None

   n = len(games)
   return {
       "pts": round(sum(g.get("pts", 0) for g in games) / n, 1),
       "reb": round(sum(g.get("reb", 0) for g in games) / n, 1),
       "ast": round(sum(g.get("ast", 0) for g in games) / n, 1),
   }


# ---------------------------------------------------------------------------
# Opponent detection
# ---------------------------------------------------------------------------

def load_schedule():
   with open("schedule.json", "r", encoding="utf-8") as f:
       return json.load(f)


def today_opponents(schedule: dict) -> dict:
   opp_map = {}
   games = schedule.get(TODAY, []) or []

   for g in games:
       home = g["home_team"]
       away = g["away_team"]
       opp_map[home] = away
       opp_map[away] = home

   return opp_map


# ---------------------------------------------------------------------------
# Main builder
# ---------------------------------------------------------------------------

def build_stats() -> dict:
   with open("rosters.json", "r", encoding="utf-8") as f:
       rosters = json.load(f)

   schedule = load_schedule()
   opponents = today_opponents(schedule)
   players_index = fetch_players_index()

   final = {}
   missing = []

   cache_avg = {}
   cache_last5 = {}

   for team, players in rosters.items():
       for player in players:
           info = players_index.get(player)

           if not info:
               missing.append(player)
               pid = None
               avg = None
               last5 = None
           else:
               pid = info["id"]

               if pid not in cache_avg:
                   cache_avg[pid] = fetch_season_avg(pid)

               if pid not in cache_last5:
                   cache_last5[pid] = fetch_last5(pid)

               avg = cache_avg[pid]
               last5 = cache_last5[pid]

           # Season averages
           games = avg.get("games_played", 0) if avg else 0
           min_dec = parse_minutes(avg.get("min")) if avg else 0
           pts = float(avg.get("pts", 0)) if avg else 0
           reb = float(avg.get("reb", 0)) if avg else 0
           ast = float(avg.get("ast", 0)) if avg else 0
           fg_pct = avg.get("fg_pct") if avg else None
           fg3_pct = avg.get("fg3_pct") if avg else None
           ft_pct = avg.get("ft_pct") if avg else None

           # Last 5
           l5_pts = last5["pts"] if last5 else 0
           l5_reb = last5["reb"] if last5 else 0
           l5_ast = last5["ast"] if last5 else 0

           opp = opponents.get(team)

           final[player] = {
               "team": team,
               "season": SEASON,

               "games": games,
               "min": min_dec,
               "pts": pts,
               "reb": reb,
               "ast": ast,
               "fg_pct": fg_pct,
               "fg3_pct": fg3_pct,
               "ft_pct": ft_pct,

               # last-5 game averages
               "last5_pts": l5_pts,
               "last5_reb": l5_reb,
               "last5_ast": l5_ast,

               # matchup
               "opponent": opp,
               "def_rank": None,

               # unused but required by UI
               "usage": 0.0,
               "pace": None,
           }

   if missing:
       print("\nUnmatched players:", file=sys.stderr)
       for m in missing:
           print(f"  - {m}", file=sys.stderr)

   return final


def main():
   print("Building player_stats.json from BallDontLie…", file=sys.stderr)
   stats = build_stats()

   with open("player_stats.json", "w", encoding="utf-8") as f:
       json.dump(stats, f, indent=2, sort_keys=True)

   print(f"Done. Wrote {len(stats)} players.", file=sys.stderr)


if __name__ == "__main__":
   main()
